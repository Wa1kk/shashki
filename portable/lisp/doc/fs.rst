Интерфейс управления файловой системой в OS-PI
==============================================

Файловая система -- это абстракция над способом хранения файлов на диске. Она должна включать следующие функции:

* подключение раздела диска;
* просмотр содержимого каталога;
* задание рабочего каталога;
* получение информации о файле/каталоге;
* создание/удаление файлов;
* создание/удаление каталогов;
* открытие/закрытие файлов;
* чтение/запись файлов;
* перемещение указателя чтения/записи;
* информация о свободном месте.

Система должна сама автоматически определять тип файловой системы при подключении раздела:
::

   (load-partition disk-num part-num)
   ; Загрузить файловую систему из раздела part-num с диска disk-num
   ; Возвращает nil
   ; Возможная ошибка - неправильный номер раздела или ошибка диска

После этой команды дерево файловой системы подключено, и можно работать с файлами.

Пути к файлам в стиле UNIX: /dir/file.txt в виде строки.

Смена рабочего каталога для относительных путей:
::

   (ch-dir <путь>)
   ; Возвращает nil
   ; Возможная ошибка - неправильный путь

Просмотр содержимого каталога:
::

   (list-dir <путь>)

Результат выполнения команды содержит список строк для файлов и пару для каталогов:
::

    ("file1.txt" ; обычный файл
     "file2.txt"
     (dir."directory")) ; каталог

Если путь неправильный -- возвращается ошибка:
::

   (error "Invalid path")

Команда получения информации о файле/каталоге:
::

   (fstat "file.txt")
   ; возвращает хеш-объект
   ((name . "file1.txt")  ;имя файла/каталога              
    (size . 424242)       ;размер в байтах               
    (attrib . 32)         ;байт атрибутов
                          ; 5      4         3        2      1      0
                          ;Archive Directory VolumeID System Hidden ReadOnly
    (ctime . 1707136932)  ;время создания файла
    (cdate . 1707136932)  ;дата создания файла
    (adate . 1707136932)  ;дата последнего обращения к файлу
    (wdate . 1707136932)  ;дата последней записи файла
    (wtime . 1707136932)) ;время последней записи файла
   ; Возможная ошибка - неправильный путь
    
Создание файла:
::

   (create-file <путь>) ; создает и открывает файл
                        ; возможные ошибки -- некорректный путь,
			; не хватает места, ошибка диска

Удаление файла:
::

   (remove-file <путь>) ; удаляет файл
                        ; возможные ошибки -- некорректный путь, ошибка диска

Создание каталога:
::

   (create-dir <путь>) ; создает каталог
                       ; возможные ошибки -- некорректный путь,
		       ; не хватает места, ошибка диска

Удаление каталога:
::

   (remove-dir <путь>) ; удаляет каталог
                       ; возможные ошибки -- некорректный путь, ошибка диска
		       
Открытие файла:
::

   (fopen "file.txt") ; возвращает объект-файл для дальнейшей работы
                      ; позиция указателя -- в начале файла
		      ; если файла нет -- ошибка пути или ошибка диска

Закрытие файла:
::

   (fclose <file-object>) ; возвращает nil или ошибку, если некорректный объект

Чтение файла:
::

   (fread file size)  ; Чтение из файла file количество байт size
   ; возвращает массив прочитанных байт
   ; возможная ошибки - ошибка диска, неправильный объект, неправильные параметры

Запись в файл:
::

   (fwrite file buf) ; Записать в файл file массив байт buf
   ; возвращает число записанных байт
   ; возможная ошибки - ошибка диска, неправильный объект, неправильные параметры

Перемещение указателя чтения/записи в файле:
::

   (fseek file offset direction)
   ; Перемещение позиции чтения/записи в файле file на offset байт
   ; возможная ошибки - ошибка диска, неправильный объект, неправильные параметры

direction принимает значения:

:begin: перемещение относительно начала файла
:end:   перемещение относительно конца файла
:cur:   перемещение относительно текущей позиции указателя

Сколько осталось свободного места в разделе:
::

   (free-space) ; возвращает размер в байтах
   
Реализация интерфейса файловой системы
--------------------------------------

Функции fclose, fread, fwrite, fseek будут работать с файловым объектом - хеш-объект.

Метод fclose достаточно определить пустым, так как файловый объект может быть освобожден сборщиком мусора. В будущих реализациях можно сделать здесь сброс буферов.

Размер блока у разных файловых систем может быть разный. Он определяется при загрузке файловой системы. При этом функции чтения и записи блоков -- одинаковые у всех файловых систем. Поэтому необходима глобальная переменная \*block-sectors\*, которая будет записываться при загрузке и использоваться функциями block-read и block-write. Удобно хранить в этой переменной число секторов по 512 байт для блока. Также нужна глобальная переменная \*block-size\* -- размер блока в байтах, для удобства расчета при чтении или записи. Тогда функции fread, fwrite, fseek могут быть реализованы  одинаково для всех файловых систем, кроме случая обновления атрибутов файла (время модификации, дата доступа). В случае записи в файл может возникнуть увеличение размера файла. В этом случае необходимо добавить новый блок в файл (метод new-block в FileSystem). Размер файла и другие атрибуты при этом также должны измениться. Поэтому нужно сделать класс File с общей функциональностью всех систем, а для конкретной системы делать класс потомок (например Fat32File), где будут действия, специфичные для этой системы.
Метод fseek просто меняет позицию чтения/записи. Список блоков будет создаваться при открытии файла.

Параметры файла (класс File), которые есть у всех файловых систем:

:name:     имя
:size:     размер файла	   
:position: позиция чтения/записи
:blocks:   список номеров блоков, например (14 15 16)
:dir:      для каталогов - дерево

Остальные параметры добавляются при открытии файла (например, дата/время модификации).

Методы класса File:

* fread - чтение блоков в буфер, атрибуты меняются в методе потомка;
* fwrite - запись блоков из буфера, атрибуты меняются в методе потомка;
* fseek - меняет указатель чтения/записи, проверяет границы;
* fclose;
* is-directory - возвращает T если файл-каталог, иначе nil.
  
Для остальных функций нужно сделать класс FileSystem, чтобы они автоматически выбирались в зависимости от загруженной файловой системы. Единственный экземпляр этого класса -- глобальный объект \*file-system\*. Тогда функции интерфейса файловой системы будут макросами:
::

   ; чтобы не было коллизии имен к имени макроса добавлять *
   (ch-dir "/") -> (ch-dir* *file-system* "/")

Тип файловой системы, а значит и класс будет определяться при загрузке раздела (load-partition).

Методы класса FileSystem делают все операции с деревом файлов.

Сами функции block-read и block-write должны быть реализованы в отдельном модуле. В простой реализации они просто читают и пишут сектора. В более оптимальной реализации они могут использовать буферизацию. Переменная \*block-sector-offset\* задает смещение в секторах места, откуда начинаются блоки. Для чтения секторов есть функции ata-read-sectors и ata-write-sectors.

Работа со структурами внутри блоков
-----------------------------------

Удобно использовать готовый макрос, который автоматически связывает имена полей со значениями, используя структуру с именами полей и размером поля в байтах:
::

   (defvar struct '((f1 . 1) ; (имя поля.число байт)
                    (f2 . 4)))

   (with-struct struct array offset ; применяет структуру struct к массиву array
                                    ; по смещению offset
	(list f1 f2))               ; вернуть список значений полей

Для строковых полей указываем префикс str:
::
   
   (defvar struct '((str name . 10) ; строковое поле из 10 байт
                    (f2 . 4)))

Вспомогательные функции
-----------------------

Разделение строки на список по символу (работа с путями):
::
   
   (split "/dir1/dir2/file1" "/") -> ("" "dir1" "dir2" "file1")
   (split "dir2/file1" "/") -> ("dir2" "file1")

Объединение списка с разделителем:
::

   (join '("" "dir1" "dir2" "file1") "/") -> "/dir1/dir2/file1"
   
Класс FileSystem
----------------

Методы:

* init <start-sector> <end-sector> - инициализация (на входе начальный и конечный сектора);
* chdir* <path> - смена рабочего пути, проверка пути (load-dir);
* listdir* <path> - просмотр каталога, проверка пути (использует load-dir);
* fstat* <path> - проверка пути (load-path), возвращает файловый объект;
* create-file* - создание файла, добавление имени в каталог. Получаем путь к родительскому каталогу файла. Если файл существует - то ошибка. Добавляется файловый объект (name:<имя>, size:0, position:0, blocks:()), который создается методом neww-file.
* new-file - пустой.
* remove-file' - удаление файла из дерева;
* create-dir' - создание каталога в дереве;
* remove-dir' - удаление каталога из дерева.

Структуру каталогов удобно хранить в естественном виде дерева из файлов и каталогов. Это будет хеш-объект с ключами - имя и значениями в виде файлового объекта. Загруженный каталог имеет ключ dir в файловом объекте. Каталоги раскрываются по мере чтения. Вспомогательный метод is-directory у файла возвращает T если файл -- каталог. Глобальный объект \*root-directory\*. Рабочий каталог -- \*working-directory\* является ссылкой на часть глобального.
::

   ; Корневой каталог
   (("File1.txt".<файловый объект>)  ; обычный файл, который уже открывался
    ("Directory 10".<файловый объект>
              dir -> (("f1.txt" . <файловый объект>)   ; раскрытый каталог
                      ("f2.txt" . <файловый объект>)))
    ("Directory" . <файловый объект>)) ; нераскрытый каталог

Работа с путями
---------------

Необходима функция load-path, которая по строке пути возвращает или nil (если путь неправильный) или дерево каталога (хеш-объект). По мере раскрытия пути читаются и добавляются в дерево другие каталоги, в файловый объект добавляется раскрытый каталог. Если путь относительный то работа идет с рабочим каталогом. Рабочий каталог используется для рекурсии, он сохраняется, меняется на часть текущего пути и в конце восстанавливается.

При изменении рабочего каталога, искомый путь проверяется и загружается. Загрузка каталога - метод load-dir, на входе список блоков каталога, на выходе объект-каталог. Этот же метод загружает корневой каталог.

Метод list-dir* использует load-dir для проверки и загрузки пути, а затем отображает дерево каталогов в требуемый список. Каталог это или файловый объект или раскрытый каталог (список).
