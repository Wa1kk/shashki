Реализация интерпретатора
=========================

Лексический анализатор (lexer.c)
--------------------------------

Лексический анализатор пропускает пустоты (пробелы, переводы строк) и выполняет распознавание лексем:

* целое число: 10;
* символ: A;
* цитата: '
* левая скобка: (;
* правая скобка: );
* конец файла.

Символ - это последовательность букв, цифр, начинающихся с буквы.

Синтаксический анализатор (parser.c)
------------------------------------

Синтаксический анализатор преобразовывает информацию из лексем и создает объекты соответствующего типа.

Представление объектов (objects.c)
----------------------------------

Каждый объект имеет тип и данные (в зависимости от типа).

Типы объектов:

* символ;
* целое число;
* пара (для представления списков).

Для символа и пары хранится указатель на соответствующую структуру, для целого числа хранится само число.

Объекты распределяются из пула (фиксированного массива) по мере надобности.

Представление символов (symbols.c)
----------------------------------

Символы хранятся в своих структурах, где есть поле - строка (массив символов). Каждый символ должен храниться в единичном экземпляре. Это можно обеспечить с помощью хеш таблицы. Для строки символа вычисляется хеш-значение, которое используется как индекс в хеш-таблице.

Представление списков
---------------------

Списки выражений представлены парой объектов. Пара состоит из двух объектов (car и cdr). Объект car - это голова списка (первый элемент). Объект cdr - это пара, которая продолжает список (хвост списка).

Список (A B C) представляется следующим образом:

.. image:: img/list.jpg

Реализация примитивов
---------------------

Каждый примитив должен быть зарегистрирован как символ (имя функции), который имеет ссылку на функцию реализации примитива. Для этого в структуре символа есть поле func.

Реализация функций
------------------

Лямбда функции - это объект (lambda (p1 ... pn) выражение). При выполнении (применении к аргументам) функции необходимо создать окружение. Окружение - это ассоциативный массив, где параметрам соответствуют вычисленные значения аргументов:
::
   
   (p1 z1) (p2 z2) ... (pn zn)

Используя это окружение, можно выполнять подстановку, вместо параметра подставляется его значение.

Вновь созданные функции представляются как лямбда функции и хранятся как значения символа (имени функции).

Реализация lambda
-----------------

Начинаем с eval: нам нужно вычислять выражения типа
::
   
   ((labmda (x) x) 1)
то есть на первом месте стоит лямбда.

Cсоответственно в eval мы должны проверять первый элемент списка, что это корректная lambda функция,это функция:
::

   int is_lambda(object_t *obj)
   
остается только:
::
   
   eval_lambda(object_t *lambda, object_t *args)
   
мы ее вызываем, передаем lambda объект и вычисленные аргументы (уже есть функция вычисляющая аргументы).
эта функция должна строить окружение, дополнительная функция:
::

   object_t * make_env(object_t *args, object_t *values)
   
   args - список аргументов (x y)
   values - список значений (1 2)
   
   возвращает окружение ((x 1) (y 2))
   
Далее нужно применить окружение к телу функции:
::
   
   apply_env(env, body)
   
то есть замена переменных в body на значение и результат попадает в eval
