Реализация интерпретатора
=========================

Лексический анализатор (lexer.c)
--------------------------------

Лекисческий анализатор пропускает пустоты (пробелы, переводы строк) и выполняет распознавание лексем:

* целое число: 10;
* символ: A;
* цитата: '
* левая скобка: (;
* правая скобка: );
* конец файла.

Символ - это последовательность букв, цифр, начинающихся с буквы.

Синтаксический анализатор (parser.c)
------------------------------------

Синнтаксический анализатор преобразовывает информацию из лексем и создает объектысоответствующего типа.

Представление объектов (objects.c)
----------------------------------

Каждый объект имеет тип и данные (в зависимости от типа).

Типы объектов:

* символ;
* целое число;
* пара (для представления списков).

Для символа и пары хранится указатель на соответствующую структуру, для целого числа хранится само число.

Объекты рапределяются из пула (фиксированного массива) по мере надобности.

Представление символов (symbols.c)
----------------------------------

Символы хранятся в своих структурах, где есть поле - строка (массив символов). Каждый символ должен храниться в единичном экземпляре. Это можно обеспечить с помощью хеш таблицы. Для строки символа вычисляется хеш-значение, которое используется как индекс в хеш-таблице.

Представление списков
---------------------

Списки выражений представлены парой объектов. Пара состоит из двух объектов (car и cdr). Объект car - это голова списка (первый элемент). Объект cdr - это пара, которая продолжает список (хвост списка).

Список (A B C) представляется следующим образом:

.. image:: img/list.jpg

Реализация примитивов
---------------------

Каждый примитив должен быть зарегистрирован как символ (имя функции), который имеет ссылку на функцию реализации примитива. Для этого в структуре символа есть поле func.

Реализация функций
------------------

Лямбда функции - это объект (lambda (p1 ... pn) выражение). При выполнении (применении к аргументам) функции необходимо создать окружение. Окружение - это ассоциативный массив, где параметрам соответствуют вычисленные значения аргументов:
::
   
   (p1 z1) (p2 z2) ... (pn zn)

Используя это окружение, можно выполнять подстановку, вместо параметра подставляется его значение.

Вновь созданные функции представляются как лямбда функции и хранятся как значения символа (имени функции).
